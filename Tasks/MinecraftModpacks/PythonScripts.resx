<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="MinecraftModpack-Curseforge" xml:space="preserve">
    <value>import urllib, urllib2, json, clr, os, zipfile, shutil, time, random, inspect, re, csv, time
from xml.etree.ElementTree import parse
clr.AddReference('RestSharp')
from RestSharp import RestClient, RestRequest
from System.Diagnostics import Process
from System.IO import File
clr.AddReference('TCAdmin.SDK')
clr.AddReference('TCAdmin.GameHosting.SDK')
from TCAdmin.GameHosting.SDK.Objects import CustomCmdLine, GameVariableConfig
from TCAdmin.SDK.Scripting import ScriptUtility
from TCAdmin.SDK.Misc import CompressionTools
from System import Version
from TCAdmin.SDK.Misc import WebClient

# Define a simple alias of ThisTaskStep.WriteLog since we will be using it a lot
try:
    ThisTaskStep.WriteLog
except NameError:
    WriteLog = Script.WriteToConsole
else:
    WriteLog = ThisTaskStep.WriteLog

class CurseForgeModpacks():
    def __init__(self, total_steps):
        self.ModpackID = ThisModpackInfo.ModpackId
        self.ModpackVersion = ThisModpackInfo.VersionId
        self.ModLoaderType = ThisModpackInfo.ModLoaderType
        self.GameVersion = ThisModpackInfo.GameVersion
        self.DeleteWorldFolders = ThisModpackInfo.DeleteWorldFolders
        self.api_key = ThisModpackInfo.CurseApiKey
        self.total_steps = total_steps - 1 if not self.DeleteWorldFolders else total_steps - 2
    
    def get_modpack_information(self):
        WriteLog('1/{} - Getting information about the modpack ID {} version {}...'.format(self.total_steps, self.ModpackID, self.ModpackVersion))
        headers = {'x-api-key': self.api_key}
        request = urllib2.Request('https://api.curseforge.com/v1/mods/{}/files/{}'.format(self.ModpackID, self.ModpackVersion), headers=headers)
        response = urllib2.urlopen(request)
        modpack_info = json.load(response)['data']
        
        if not modpack_info['isServerPack'] and 'serverPackFileId' in modpack_info:
            WriteLog('1/{} - Serverpack ID: {}'.format(self.total_steps, modpack_info['serverPackFileId']))
            request = urllib2.Request('https://api.curseforge.com/v1/mods/{}/files/{}'.format(self.ModpackID, modpack_info['serverPackFileId']), headers=headers)
            response = urllib2.urlopen(request)
            ThisTaskStep.UpdateProgress(33)
            serverpack_info = json.load(response)['data']
            #Use gameversion information from parentProjectFileId if none is set in the information about the serverpack
            if len(serverpack_info['gameVersions']) &lt; 1:
                serverpack_info['gameVersions'], serverpack_info['sortableGameVersions'] = modpack_info['gameVersions'], modpack_info['sortableGameVersions']
                modpack_info = serverpack_info
            else:
                modpack_info = serverpack_info
            WriteLog('1/{} - Serverpack information received'.format(self.total_steps))


        return modpack_info

    def install_modloader(self, modloader, included_installer_jar, specific_modloader_version=None):
        isNeo = False
        WriteLog('4/{} - Beginning modloader installation'.format(self.total_steps))

        ThisTaskStep.UpdateProgress(0)
        os.chdir(ThisService.RootDirectory)
        for version_info in modloader['sortableGameVersions']:
            if version_info['gameVersionTypeId'] == 68441:
                modloader_type = version_info['gameVersionName']
                break
            else:
                modloader_type = None
        if len(modloader['gameVersions']) &lt; 2:
            if not self.ModLoaderType:
                raise Exception('You need to specify a modloader to install. Please restart the installation.')
        modloader['gameVersions'].sort()
        game_version = modloader['gameVersions'][0] if not self.GameVersion else self.GameVersion

        #If a modloader installer was not included in the modpack files, manually download and install the modloader.
        #If an installer was included, run that instead.
        if included_installer_jar is None or (not included_installer_jar and specific_modloader_version):
            if self.ModLoaderType in ['Forge', 'NeoForge'] or modloader_type in ['Forge', 'NeoForge']: #Handle forge installation
                isNeo = self.ModLoaderType == 'NeoForge' or modloader_type == 'NeoForge'
                headers = {'x-api-key': self.api_key}
                request = urllib2.Request('https://api.curseforge.com/v1/minecraft/modloader?version={}'.format(str(game_version)), headers=headers)
                response = urllib2.urlopen(request)
                data = json.load(response)['data']
                latest_modloader_versions = [] #for some reason, there can be multiple "latest" versions of a modloader...
                for version in data:
                    if version['latest']:
                       latest_modloader_versions.append(version['name'])

                modloader_version = max(latest_modloader_versions)
                request = urllib2.Request('https://api.curseforge.com/v1/minecraft/modloader/{}'.format(str(modloader_version)), headers=headers)
                response = urllib2.urlopen(request)
                data = json.load(response)['data']
                modloader_version = data['forgeVersion'] if not specific_modloader_version else specific_modloader_version
                
                #Fix for forge versions up until 12.18.0.2007. These versions has Minecraft version suffixed. Only relevant for Forge.
                if 'Forge' in {self.ModLoaderType, modloader_type} and Version(modloader_version).CompareTo(Version('12.18.0.2008')) &lt; 0:
                    modloader_version = modloader_version+'-'+game_version
                if isNeo:
                    if Version(data['minecraftVersion']).CompareTo(Version('1.20.1')) &gt; 0:
                        modloader_installer_url = 'https://maven.neoforged.net/releases/net/neoforged/neoforge/{0}/neoforge-{0}-installer.jar'.format(modloader_version)
                    else:
                        modloader_installer_url = 'https://maven.neoforged.net/releases/net/neoforged/forge/{0}-{1}/forge-{0}-{1}-installer.jar'.format(game_version, modloader_version)
                else:
                    modloader_installer_url = 'https://maven.minecraftforge.net/net/minecraftforge/forge/{0}-{1}/forge-{0}-{1}-installer.jar'.format(game_version, modloader_version)
                installer_jar = 'forge-{}-{}-installer.jar'.format(data['minecraftVersion'], modloader_version)
                modloader_jar = data['filename']
            if self.ModLoaderType == 'Fabric' or modloader_type == 'Fabric':
                # Find the latest version of the fabric installer and download it.
                fabric_metadata = urllib2.urlopen('https://maven.fabricmc.net/net/fabricmc/fabric-installer/maven-metadata.xml')
                xml_data = parse(fabric_metadata)
                modloader_version = xml_data.find('./versioning/release').text
                modloader_installer_url = 'https://maven.fabricmc.net/net/fabricmc/fabric-installer/{0}/fabric-installer-{0}.jar'.format(modloader_version)
                installer_jar = 'fabric-installer-{}.jar'.format(modloader_version)
                modloader_jar = 'fabric-server-launch.jar'
            #Download the modloader installer
            wc = WebClient()
            wc.DownloadFileAsync(modloader_installer_url, os.path.join(ThisService.RootDirectory, installer_jar))
            while wc.DownloadError == None and not wc.DownloadProgress == 100:
                ThisTaskStep.UpdateProgress(wc.DownloadProgress)
                ThisTaskStep.RewriteLastLogEntry('4/{} - Downloading modloader "{}" ({}%)'.format(self.total_steps, modloader_installer_url, wc.DownloadProgress), False)
            if wc.DownloadError:
                raise Exception('Download failed: {}'.format(wc.DownloadError))
            if os.path.exists('libraries'):
                shutil.rmtree('libraries')
        else:
            isNeo = self.ModLoaderType == 'NeoForge' or modloader_type == 'NeoForge' #Handle forge installation
            installer_jar = included_installer_jar
            WriteLog('4/{} - Modloader installer found in modpack ({})'.format(self.total_steps, installer_jar))
            modloader_jar = installer_jar.replace('-installer', '')
            if 'fabric' in modloader_jar:
                modloader_version = ((modloader_jar.replace('fabric-'.format(game_version),'')).replace('.jar', '')).replace('-', '')
                modloader_jar = 'fabric-server-launch.jar'
            else:
                modloader_version = (modloader_jar.replace('forge-{}-'.format(game_version),'')).replace('neoforge-', '').replace('.jar', '')

        WriteLog('4/{} - Installing modloader'.format(self.total_steps))
        arg = ' -jar {} --installServer'.format(installer_jar) if 'Forge' in [self.ModLoaderType, modloader_type] or isNeo else ' -jar {0} server -downloadMinecraft -mcversion {1} -dir {2}'.format(installer_jar, game_version, ThisService.RootDirectory)
        p = Process()
        p.StartInfo.FileName = ThisService.Executable
        p.StartInfo.Arguments = arg
        p.Start()
        fakeprogress = 0
        while not p.HasExited:
            ThisTaskStep.UpdateProgress(fakeprogress)
            fakeprogress += random.randint(3,8)
            if fakeprogress &gt; 100 :
                fakeprogress = 0
            time.sleep(random.randint(2,5))
        if p.ExitCode != 0:
            # Modloader installation failed
            if not 'Forge' in [self.ModLoaderType, modloader_type] and not isNeo:
                raise Exception('Fabric modloader installation failed. If possible, select another version or modloader')
            elif 'Forge' in [self.ModLoaderType, modloader_type] and included_installer_jar:
                # Sometimes included modloader fails. Try downloading the latest.
                WriteLog('4/{} - Included Forge modloader installation failed. Trying latest modloader for version {}'.format(self.total_steps, game_version))
                self.install_modloader(modloader, None)
            else:
                raise Exception('Modloader installation failed. There is most likely a log that explains why')
        
        if 'Forge' in [self.ModLoaderType, modloader_type] and not isNeo:
            # Check if forge installed a '-universal.jar'
            universal_jar = os.path.join(ThisService.RootDirectory, installer_jar.replace('-installer', '-universal'))
            WriteLog('4/{} - Checking if Forge installer created universal jar {}'.format(self.total_steps, universal_jar))
            if os.path.isfile(universal_jar):
                modloader_jar = universal_jar
                WriteLog('4/{} - Modloader jar changed to {}'.format(self.total_steps, modloader_jar))
                
        ThisTaskStep.UpdateProgress(90)
        WriteLog('4/{} - Modloader installed'.format(self.total_steps))
        #Delete the modloader installer
        if os.path.isfile(installer_jar):
            os.remove(installer_jar)
        ThisTaskStep.UpdateProgress(100)
        os.chdir(os.path.join(TCAdminFolder, 'Monitor'))
        return [modloader_jar, game_version, modloader_version], isNeo

    def download_modpack(self, modpack_info):
        file_name = modpack_info['fileName']
        file_size = modpack_info['fileLength']/(1024**2)
        serverpack_file_id = str(modpack_info['id'])
        WriteLog('2/{} - Downloading modpack "{}" ({}MB)'.format(self.total_steps, file_name, file_size))
        if modpack_info['downloadUrl'] == None:
            #In some cases, the downloadUrl is not set. We can fix this pretty easily as the download links always seems to be https://edge.forgecdn.net/files/&lt;first 4 digits of file id&gt;/&lt;last three digits of file id&gt;/&lt;file name&gt;
            modpack_info['downloadUrl'] = 'https://edge.forgecdn.net/files/{}/{}/{}'.format(serverpack_file_id[0:4], serverpack_file_id[-3:], file_name)
        wc = WebClient()
        wc.DownloadFileAsync(modpack_info['downloadUrl'], os.path.join(ThisService.RootDirectory, file_name))
        while wc.DownloadError == None and not wc.DownloadProgress == 100:
            ThisTaskStep.UpdateProgress(wc.DownloadProgress)
            ThisTaskStep.RewriteLastLogEntry('2/{} - Downloading modpack "{}" ({}MB, {}%)'.format(self.total_steps, file_name, file_size, int(wc.DownloadProgress)), False)
        if wc.DownloadError:
            raise Exception('Download failed: {}'.format(wc.DownloadError))
        ThisTaskStep.UpdateProgress(100)

        return file_name

    def extract_modpack(self, file_name):
        ThisTaskStep.UpdateProgress(0)
        specific_modloader_version = None
        progress = 0
        WriteLog('3/{} - Extracting "{}"'.format(self.total_steps, file_name))
        zip_file = os.path.join(ThisService.RootDirectory, file_name)
        tmp_dir = os.path.join(ThisService.RootDirectory, str(self.ModpackID)+'-tmp')
        c = CompressionTools()
        c.KeepListOfExtractedFiles = True
        c.SetFileOwnerAutomatically = True
        c.DecompressAsync(zip_file, tmp_dir)
        while c.Error == None and not c.Progress == 100:
            ThisTaskStep.UpdateProgress(c.Progress / 2)
            ThisTaskStep.RewriteLastLogEntry('3/{} - Extracting "{}" ({}%)'.format(self.total_steps, file_name, c.Progress), False)
        time.sleep(0.1)
        WriteLog('3/{} - Extraction complete'.format(self.total_steps))
        extracted_files = list(c.ExtractedFiles.ToArray())
        #Get the first item where a subfolder is called "mods" using regex. Will only match if a .jar file is directly inside the mods folder, not in a subfolder.
        if ThisServer.OperatingSystem.ToString() == 'Windows':
            r = re.compile("^.*\\\\mods\\\\[^\\\\]*\.jar$")
        else:
            r = re.compile("^.*\/mods\/[^\/]*\.jar$")
        removepath = list(filter(r.match, extracted_files))
        if len(removepath) &lt; 1 and os.path.isfile(os.path.join(tmp_dir, 'mods.csv')):
            #Dirty hack in case there's no mods folder, but a mods.csv file is present
            removepath = list(os.path.join(tmp_dir, 'mods', 'mods.jar'))
            WriteLog('3/{} - No mods folder, but mods.csv available. Downloading files...'.format(self.total_steps))
            with open(os.path.join(tmp_dir, 'mods.csv'), 'rb') as csvfile:
                download_files = list(csv.reader(csvfile, delimiter=','))
                total_files = len(download_files)
                WriteLog('3/{} - Downloading files using mods.csv'.format(self.total_steps))
                file_number = 0
                for row in download_files:
                    file_number += 1
                    file_url = row[0]
                    file_name = row[1]
                    extracted_files.append(row[1]) #Add the file to extracted_files list
                    percentage_downloaded = float(file_number) / total_files * 100
                    if not os.path.isdir(os.path.dirname(os.path.join(ThisService.RootDirectory, row[1]))):
                        os.makedirs(os.path.dirname(os.path.join(ThisService.RootDirectory, row[1])))
                    wc = WebClient()
                    wc.DownloadFileAsync(file_url, os.path.join(ThisService.RootDirectory, file_name))
                    while wc.DownloadError == None and not wc.DownloadProgress == 100:
                        ThisTaskStep.UpdateProgress(percentage_downloaded)
                        ThisTaskStep.RewriteLastLogEntry('3/{} - Downloading file {}/{} ({}%)'.format(self.total_steps, file_number, total_files, int(percentage_downloaded)), False)
                    if wc.DownloadError:
                        raise Exception('Download failed: {}'.format(wc.DownloadError))

                    #Check if there's a modloader installer included
                    regex = re.compile(".*-installer.jar")
                    match  = filter(regex.match, extracted_files)

                    if len(match) &gt; 0:
                        installer_jar = os.path.basename(match[0])
                    else:
                        installer_jar = None
       
        elif len(removepath) &lt; 1:
            WriteLog('3/{} - No mods available in the pack'.format(self.total_steps))
            raise Exception('3/{} - No mods available in the pack'.format(self.total_steps))
        else:
            #Get the parent folder of the "mods" folder
            removepath = os.path.dirname(removepath[0])
            if ThisServer.OperatingSystem.ToString() == 'Windows':
                removepath = removepath.replace('\\mods', '')
            else:
                removepath = removepath.replace('/mods', '')
            #Check if there's a modloader installer included
            regex = re.compile(".*-installer.jar")
            match  = filter(regex.match, extracted_files)

            if len(match) &gt; 0:
                installer_jar = os.path.basename(match[0])
            else:
                installer_jar = None

            #ThisTaskStep.UpdateProgress(0)
            total_files = len(extracted_files)
            progress = 50
            WriteLog('3/{} - Moving files from temporary directory ({}/{})'.format(self.total_steps, progress, total_files))
            for i in extracted_files:
                try:
                    progress += 1
                    if os.path.basename(i) == 'eula.txt':
                        continue
                    dst = os.path.join(ThisService.RootDirectory, i.replace(removepath, '')[1:])
                    if os.path.basename(i) == 'variables.txt':
                        WriteLog('3/{} - variables.txt found. Loading modloader version from that file.'.format(self.total_steps))
                        #Assign Forge version
                        with open(i, "r") as file:
                            #Read all lines
                            lines = file.readlines()
                            # Iterate through each line
                            for line in lines:
                                if line.startswith("#"):
                                    #Skip comments
                                    continue
                                # Split the line into key and value using '=' as separator
                                key, value = line.strip().split("=")
                                # Check if the key is 'MODLOADER_VERSION'
                                if key == "MODLOADER_VERSION":
                                    # Assign the value to the variable
                                    specific_modloader_version = value
                                    WriteLog('3/{} - Modloader version: {}'.format(self.total_steps, specific_modloader_version))
                                    # Exit the loop once found (assuming there's only one occurrence)
                                    break
                        WriteLog('3/{} - Resuming moving files...'.format(self.total_steps))
                    if not os.path.exists(os.path.dirname(dst)):
                        os.makedirs(os.path.dirname(dst))
                    shutil.move(i, dst)
                    ThisTaskStep.RewriteLastLogEntry('3/{} - Moving files from temporary directory ({}/{})'.format(self.total_steps, progress - 50, total_files), False)
                    ThisTaskStep.UpdateProgress(50 + float(progress) / total_files * 50)
                except Exception as e:
                    raise Exception('Could not move {} to {}. Error: {}'.format(i, dst, e))
            WriteLog('3/{} - All files have been moved'.format(self.total_steps))
            if os.path.isfile(zip_file):
                WriteLog('3/{} - Deleting temporary directory and zip file'.format(self.total_steps))
                #Delete the zip file and the temporary directory. If the zip file is still open by TCAdmin Monitor, wait for a second and then try again.
                #Also delete fabric-server-launcher.properties if that exists. This is needed because the file usually contains the name that the vanilla jar _should_ be called, but downloading from the fabric installer
                #just gives us server.jar
                while True:
                    try:
                        os.remove(zip_file)
                        if os.path.isfile(os.path.join(ThisService.RootDirectory, 'fabric-server-launcher.properties')):
                            os.remove(os.path.join(ThisService.RootDirectory, 'fabric-server-launcher.properties'))
                        shutil.rmtree(tmp_dir)
                        break
                    except Exception, e:
                        WriteLog('3/{} - {} is still open. Trying to delete again'.format(self.total_steps, file_name))
                        time.sleep(1)

        return installer_jar, specific_modloader_version
            
    def set_commandline(self, modloader_jar, isNeo):
        WriteLog('5/{} - Configuring the commandline'.format(self.total_steps))
        cmdline = CustomCmdLine()
        util = ScriptUtility
        util = ThisService.GetScriptUtility();
        util.ExecuteScripts = False;
        cmdline.ServiceId = ThisService.ServiceId
        if ThisApiInfo.Name.Length &gt; 25 :
            cmdline.Description = ThisApiInfo.Name.Substring(0, 25)
        else :
            cmdline.Description = ThisApiInfo.Name

        cmdline.Variables.LoadXml(ThisService.Variables.ToString())
        cmdline.Variables['CM:ModpackCmd'] = True
        if not modloader_jar[0] == False:
            cmdline.Variables[ThisModpackInfo.JarVariable] = modloader_jar[0].replace(ThisService.RootDirectory, '')
        cmdline_template = ThisGame.CommandLines.DefaultCustomCmdLine
        if ThisService.Private and ThisGame.CommandLines.PrivateCustomCmdLine != '' :
            cmdline_template = ThisGame.CommandLines.PrivateCustomCmdLine
        elif cmdline_template == '' :
            cmdline_template = ThisGame.CommandLines.DefaultCmdLine
        if int(modloader_jar[2].split('.')[0]) &lt; 37 and not isNeo:
            cmdline_template = GameVariableConfig.ReplaceVariablesWithCustomTemplates(ThisGame.CustomVariables, cmdline_template)
        else: #Remove jar file from commandline if Forge version 37.0.0 or later
            args_os = 'win' if ThisServer.OperatingSystem.ToString() == 'Windows' else 'unix'
            forge_type = 'neoforged' if isNeo else 'minecraftforge'
            if forge_type == 'neoforged' and Version(modloader_jar[1]).CompareTo(Version('1.20.1')) &gt; 0:
                cmdline_template = GameVariableConfig.ReplaceVariablesWithCustomTemplates(ThisGame.CustomVariables, cmdline_template).replace('-jar ![{}]'.format(ThisModpackInfo.JarVariable), '@libraries/net/{}/neoforge/{}/{}_args.txt'.format(forge_type, modloader_jar[2], args_os))
            else:
                cmdline_template = GameVariableConfig.ReplaceVariablesWithCustomTemplates(ThisGame.CustomVariables, cmdline_template).replace('-jar ![{}]'.format(ThisModpackInfo.JarVariable), '@libraries/net/{}/forge/{}-{}/{}_args.txt'.format(forge_type, modloader_jar[1], modloader_jar[2], args_os))
        cmdline.CommandLine = util.ProcessDynamicValues(ThisGame.CustomVariables, cmdline.Variables, cmdline_template, True)
        cmdline.GenerateKey()
        cmdline.Save()
        ThisService.OverrideCommandLine = True
        ThisService.UnparsedCommandLine = cmdline.CommandLine
        ThisService.CustomFields['d3b2aa93-7e2b-4e0d-8080-67d14b2fa8a9:CmdLineManager:CmdLineName'] = 'CUS:{0}'.format(cmdline.CmdLineId)
        ThisService.Save()
        ThisService.Configure()
        
    def get_level_name(self, filename):
        with open(filename, 'r') as file:
            for line in file:
                if line.startswith("level-name="):
                    level_name = line.split("=", 1)[1].strip()
                    WriteLog("6/{} - Level name detected as {}".format(self.total_steps, level_name))
                    return level_name
        return None
    
    def delete_world_folders(self, level_name):
        if level_name == '':
            WriteLog('6/{} - Level name is blank. Cannot delete world folders'.format(self.total_steps))
            return
        WriteLog("6/{} - Deleting world folders".format(self.total_steps))
        level_name = os.path.join(ThisService.RootDirectory, level_name)
        folders_to_delete = [level_name, level_name + "_the_end", level_name + "_nether"]
        for folder in folders_to_delete:
            if os.path.exists(folder) and os.path.isdir(folder):
                shutil.rmtree(folder)  # Delete non-empty directory
                WriteLog("6/{} - Deleted folder and its contents: {}".format(self.total_steps, folder))
            else:
                WriteLog("6/{} - Folder does not exist: {}".format(self.total_steps, folder))


def main():
    total_steps = len(inspect.getmembers(CurseForgeModpacks, inspect.ismethod))
    installer = CurseForgeModpacks(total_steps)
    modpack_info = installer.get_modpack_information()
    file_name = installer.download_modpack(modpack_info)
    installer_jar, specific_modloader_version = installer.extract_modpack(file_name)
    modloader_installer, isNeo = installer.install_modloader(modpack_info, installer_jar, specific_modloader_version)
    installer.set_commandline(modloader_installer, isNeo)
    
    if installer.DeleteWorldFolders:
        # Delete level-name folder(s)
        properties_file = os.path.join(ThisService.RootDirectory, 'server.properties')
        level_name = installer.get_level_name(properties_file)
        installer.delete_world_folders(level_name)

if __name__ == '&lt;module&gt;':
    main()</value>
  </data>
  <data name="MinecraftModpack-FTB" xml:space="preserve">
    <value>import urllib, urllib2, json, clr, os, zipfile, shutil, time, random, inspect, re
clr.AddReference('RestSharp')
from RestSharp import RestClient, RestRequest
from System.Diagnostics import Process
from System.IO import File
clr.AddReference('TCAdmin.SDK')
clr.AddReference('TCAdmin.GameHosting.SDK')
from TCAdmin.GameHosting.SDK.Objects import CustomCmdLine, GameVariableConfig
from TCAdmin.SDK.Scripting import ScriptUtility
from TCAdmin.SDK.Misc import CompressionTools
from System import Version
from TCAdmin.SDK.Misc import WebClient

# Define a simple alias of ThisTaskStep.WriteLog since we will be using it a lot
try:
    ThisTaskStep.WriteLog
except NameError:
    WriteLog = Script.WriteToConsole
else:
    WriteLog = ThisTaskStep.WriteLog

client = RestClient()

class FTBModpacks():
    def __init__(self, ModpackId, ModpackVersion, ModpackName):
        self.ModpackID = ModpackId
        self.ModpackVersion = ModpackVersion
        self.ModpackName = ThisApiInfo.Name
        self.api_key = ThisModpackInfo.CurseApiKey
        self.DeleteWorldFolders = ThisModpackInfo.DeleteWorldFolders
    
    def download_serverpack_installer(self):
        WriteLog('Downloading modpack installer for {}'.format(self.ModpackName))
        wc = WebClient()
        installer_filename = os.path.join(ThisService.RootDirectory, 'ftb-serverpack-installer.exe') if ThisServer.OperatingSystem.ToString() == 'Windows' else os.path.join(ThisService.RootDirectory, 'ftb-serverpack-installer')
        operating_system = 'windows' if ThisServer.OperatingSystem.ToString() == 'Windows' else 'linux'
        installer_url = 'https://api.modpacks.ch/public/modpack/{}/{}/server/{}'.format(self.ModpackID, self.ModpackVersion, operating_system)
        wc.DownloadFileAsync(installer_url, installer_filename)
        while wc.DownloadError == None and not wc.DownloadProgress == 100:
                ThisTaskStep.UpdateProgress(wc.DownloadProgress)
                ThisTaskStep.RewriteLastLogEntry('Downloading modloader "{}" ({}%)'.format(installer_filename.replace(ThisService.RootDirectory, ''), wc.DownloadProgress), False)
        if wc.DownloadError:
            raise Exception('Download failed: {}'.format(wc.DownloadError))
        
        ThisTaskStep.UpdateProgress(100)
        WriteLog('Modpack installer downloaded')
        
        return installer_filename
            
    def install_modpack(self, installer_filename):
        ThisTaskStep.UpdateProgress(0)
        WriteLog('Installing modpack {}'.format(self.ModpackName))
        if ThisServer.OperatingSystem.ToString() == 'Linux' :
            Process.Start("chmod", "+x {}".format(installer_filename)).WaitForExit()
        arg = '{} {} --auto --path {} --nojava'.format(self.ModpackID, self.ModpackVersion, ".")
        p = Process()
        p.StartInfo.FileName = installer_filename
        p.StartInfo.WorkingDirectory = ThisService.RootDirectory
        p.StartInfo.Arguments = arg
        p.Start()
        fakeprogress = 0
        while not p.HasExited :
            ThisTaskStep.UpdateProgress(fakeprogress)
            fakeprogress += 5
            if fakeprogress &gt; 100 :
                fakeprogress = 0
            time.sleep(0.5)

        WriteLog('Installer exit code: {0}'.format(p.ExitCode))
            
        ThisTaskStep.UpdateProgress(100)
        if os.path.isfile(installer_filename):
            os.remove(installer_filename)
        WriteLog('Modpack installed')
        

    def set_commandline(self):
        WriteLog('Configuring the commandline')
        cmdline = CustomCmdLine()
        util = ScriptUtility
        util = ThisService.GetScriptUtility();
        util.ExecuteScripts = False;
        cmdline.ServiceId = ThisService.ServiceId
        
        #Find the relevant information for the commandline
        pattern = re.compile("((-jar .*jar|@libraries\/net\/.*.txt|@libraries\\\\net\\\\.*.txt))")
        extension = 'bat' if ThisServer.OperatingSystem.ToString() == 'Windows' else 'sh'
        for i, line in enumerate(open(os.path.join(ThisService.RootDirectory, 'start.{}'.format(extension)))):
            for match in re.finditer(pattern, line):
                modloader_jar = match.group()
        if ThisApiInfo.Name.Length &gt; 25 :
            cmdline.Description = ThisApiInfo.Name.Substring(0, 25)
        else :
            cmdline.Description = ThisApiInfo.Name

        cmdline.Variables.LoadXml(ThisService.Variables.ToString())
        cmdline.Variables['CM:ModpackCmd'] = True
        cmdline_template = ThisGame.CommandLines.DefaultCustomCmdLine

        if ThisService.Private and ThisGame.CommandLines.PrivateCustomCmdLine != '' :
            cmdline_template = ThisGame.CommandLines.PrivateCustomCmdLine
        elif cmdline_template == '' :
            cmdline_template = ThisGame.CommandLines.DefaultCmdLine
        if not '@' in modloader_jar:
            cmdline_template = GameVariableConfig.ReplaceVariablesWithCustomTemplates(ThisGame.CustomVariables, cmdline_template)
            cmdline.Variables[ThisModpackInfo.JarVariable] = modloader_jar.replace('-jar', '')
        else: #Remove jar file from commandline if Forge version 37.0.0 or later
            cmdline_template = GameVariableConfig.ReplaceVariablesWithCustomTemplates(ThisGame.CustomVariables, cmdline_template).replace('-jar ![{}]'.format(ThisModpackInfo.JarVariable), modloader_jar)
        cmdline.CommandLine = util.ProcessDynamicValues(ThisGame.CustomVariables, cmdline.Variables, cmdline_template, True)
        cmdline.GenerateKey()
        cmdline.Save()
        ThisService.OverrideCommandLine = True
        ThisService.UnparsedCommandLine = cmdline.CommandLine
        ThisService.CustomFields['d3b2aa93-7e2b-4e0d-8080-67d14b2fa8a9:CmdLineManager:CmdLineName'] = 'CUS:{0}'.format(cmdline.CmdLineId)
        ThisService.Save()
        ThisService.Configure()
        
    def get_level_name(self, filename):
        with open(filename, 'r') as file:
            for line in file:
                if line.startswith("level-name="):
                    level_name = line.split("=", 1)[1].strip()
                    WriteLog("Level name detected as {}".format(level_name))
                    return level_name
        return None
    
    def delete_world_folders(self, level_name):
        if level_name == '':
            WriteLog('Level name is blank. Cannot delete world folders')
            return
        WriteLog("Deleting world folders")
        level_name = os.path.join(ThisService.RootDirectory, level_name)
        folders_to_delete = [level_name, level_name + "_the_end", level_name + "_nether"]
        for folder in folders_to_delete:
            if os.path.exists(folder) and os.path.isdir(folder):
                shutil.rmtree(folder)  # Delete non-empty directory
                WriteLog("Deleted folder and its contents: {}".format(folder))
            else:
                WriteLog("Folder does not exist: {}".format(folder))

def main():
    installer = FTBModpacks(ThisModpackInfo.ModpackId, ThisModpackInfo.VersionId, ThisApiInfo.Name)
    installer_filename = installer.download_serverpack_installer()
    installer.install_modpack(installer_filename)
    installer.set_commandline()
    
    if installer.DeleteWorldFolders:
        # Delete level-name folder(s)
        properties_file = os.path.join(ThisService.RootDirectory, 'server.properties')
        level_name = installer.get_level_name(properties_file)
        installer.delete_world_folders(level_name)
        
if __name__ == '&lt;module&gt;':
    main()</value>
  </data>
</root>